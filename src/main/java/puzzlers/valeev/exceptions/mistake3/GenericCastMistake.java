package puzzlers.valeev.exceptions.mistake3;

import java.util.*;

/**
 * Generic types and implicit casts
 * <p>
 * Inspired by: 100 Java mistakes and how to avoid them (Tagir Valeev) - Mistake 43, Section 1
 * <p>
 * Problem:
 * ClassCastExceptions can occur even when there is no explicit cast expression in the source code.
 * This happens due to "Type Erasure," where the JVM ignores generic type parameters at runtime.
 * <p>
 * Expected behavior:
 * Developers expect that if a list is declared as {@code List<String>}, it can only contain strings,
 * and the compiler will prevent any heap pollution or invalid type insertions.
 * <p>
 * Actual behavior:
 * - Erasure: At runtime, {@code List<String>} and {@code List<Integer>} both become the raw type {@code List}.
 * - Implicit Casts: The compiler inserts hidden casts (e.g., {@code (String) list.get(0)}) to bridge
 * generic types to bytecode.
 * - Time Bombs: Unchecked casts or raw types allow invalid objects (like an Integer) into a String list.
 * The program doesn't crash when the item is added, but "explodes" later during retrieval.
 * <p>
 * Explanation:
 * - Type parameters (like {@code E}) are replaced by their upper bound (usually {@code Object}) in bytecode.
 * - If you bypass compile-time checks (using raw types or unchecked casts), you can corrupt a collection.
 * - The {@code ClassCastException} is thrown by the synthetic/implicit cast generated by the compiler.
 * <p>
 * Ways to Avoid:
 * - Use PECS (Producer Extends, Consumer Super): Use {@code ? extends T} for read-only access to allow
 * more flexible, safe type passing.
 * - Use Adapter Methods: Use {@code Collections.unmodifiableList()} to safely treat a {@code List<String>}
 * as a {@code List<? extends CharSequence>}.
 * - Avoid Raw Types: Do not use {@code List} without parameters; use {@code -Xlint:rawtypes} to find them.
 * - Checked Collections: Use {@code Collections.checkedList(list, String.class)} to force the failure
 * to happen immediately when an invalid element is added (fail-fast).
 * - Avoid Generic Arrays: Java doesn't support them natively; use {@code ArrayList} instead.
 * <p>
 * Lesson:
 * - Generics are a compile-time fiction.
 * - An unchecked warning is a sign of a potential runtime crash.
 * - Use wildcards and checked wrappers to maintain type integrity across API boundaries.
 */
public class GenericCastMistake {

    // --- Example 1: The "Time Bomb" with Unchecked Casts ---
    public void triggerTimeBomb() {
        List<String> list = new ArrayList<>();
        List<?> objects = list;

        // This is an "Unchecked cast" warning.
        // No error happens here, but the list is now corrupted.
        ((List<Object>) objects).add(1);

        try {
            printFirstItem(list);
        } catch (ClassCastException e) {
            System.out.println("Bomb exploded: " + e.getMessage());
        }
    }

    public void printFirstItem(List<String> list) {
        // The compiler secretly changes this to: String s = (String) list.get(0);
        String s = list.get(0);
        System.out.println(s);
    }

    // --- Example 2: Safe API with Wildcards (PECS) ---
    // Using '? extends' allows us to accept List<String> even if the method asks for CharSequence
    public void processSequences(List<? extends CharSequence> list) {
        for (CharSequence cs : list) {
            System.out.println(cs.length());
        }
        // list.add("new string"); // Compilation error! Safe from corruption.
    }

    // --- Example 3: The Adapter Strategy ---
    public void useAdapter(List<String> strings) {
        // Collections.unmodifiableList maps List<T> to List<? extends T>, effectively allowing
        // a safe upcast to a more abstract type without warnings.
        processLegacyLibrary(Collections.unmodifiableList(strings));
    }

    private void processLegacyLibrary(List<CharSequence> list) {
        System.out.println("Processing safely...");
    }

    // --- Example 4: Fail-Fast with Checked Collections ---
    public void investigateCorruption() {
        // Wrapping the list makes it check types at runtime during 'add()'
        List<String> list = Collections.checkedList(new ArrayList<>(), String.class);
        List<?> objects = list;

        try {
            ((List<Object>) objects).add(1); // Exception happens HERE, not later!
        } catch (ClassCastException e) {
            System.out.println("Caught corruption at the source: " + e.getMessage());
        }
    }

    public static void main(String[] args) {
        GenericCastMistake mistake = new GenericCastMistake();
        mistake.triggerTimeBomb();
        mistake.investigateCorruption();
    }
}